

-- initialize null node after a so that delete wont throw error when list is empty
-- the head of the list is a dummy node
val newStack = 
    let val nullNode = new [] in
    let val dummyHead = new [] in
    dummyHead := ["FRONT", nullNode] ;
    nullNode := ["NULL", nullNode];
    dummyHead
;;


-- complete the following functions

val next = \a. 
    head(tail !a) 
;;

val get = \a. 
    head(!a) 
;;

val peek = \front. 
    head(!(next front))
;;

val update = \e. \front. 
    --a := [e, next a] 
    next front := [e, head(tail(!(next front)))] 
;;

val insert = \e. \a.
    let val b = new [] in
    b := [e,next(a)];
    a := [get a, b] 
;;

--val insert = \e. \a.
--   let val b = newCList e in
--    b := [get b,next(a)];
--    a := [get a, b] ;
--    b
--;;


-- initializes a copy of the element to be removed on the heap
-- try to figure out how to just do let val b = ((head (!(next a))))
val pop = \a. 
    --let val b = (head (!(next a)))
    --[b, head (tail (!(next a)))] 

    let val b = new [] in
    b := [(head (!(next a))), head (tail (!(next a)))] ;

    --let val b = newStack (head (!(next a))) in
    --b := [get b, head (tail (!(next a)))] ;
    a := [get a,head (tail (!(next a)))] ;
    b
    ;;



-- console:
-- my solution is better than the linked-list.lc because I have insert methods and pop method. the head of the list remains the same always
-- no need to remember the last cons element i pushed (his example the head always changes)
-- check if heads next is the null node, if it isnt then return then next node, else return false -- or do nothing
-- case (head (!(next a))) != "NULL" of { true -> !(next a), _ -> false} ;;

--val head = newStack 1;;
--insert 2 head ;;


-- update the first element in the stack 
 --(next front) := [200, head(tail(!(next front)))] ;;





-- now make bst

val bstNode = \e.
    let val node = new [] in
    node := [e,"NULL", "NULL"];
    node
;;

val nodeVal = \node.
    head(!node)
    ;;

val leftChild = \node.
    -- make sure that we are not accessing a null node
    -- THIS MIGHT NOT BE NECESSARY
    case node == "NULL" of {
        true -> "NULL",
        false -> (head (tail(!node)))
    }
;;

val rightChild = \node.
    (head (tail(tail(!node)))) 
;;

val insertNode = \e. \root.
    -- node that we are inserting
    let val node = bstNode e in 
    let val curr = new [] in -- curr is just a pointer
    let val flag = new [] in
    flag := true;
    curr := root; -- starts pointing to the address of root
    node := [nodeVal node, leftChild node, rightChild node] ;

    while !flag == true do 
        case (e < (nodeVal (!curr))) of {
            true -> case (leftChild (!curr)) == "NULL" of {
                -- we found where we should insert
                true -> flag := false,

                -- we havent found our spot, keep interating through left
                false -> curr := leftChild (!curr) --[nodeVal (leftChild curr), leftChild (leftChild curr), rightChild (leftChild curr)]

            },
            false -> case (rightChild (!curr)) == "NULL" of {
                true -> flag := false,
                false ->  curr := rightChild (!curr) -- [nodeVal (rightChild curr), leftChild (rightChild curr), rightChild (rightChild curr)]
            }
        } ;

    case (e < (nodeVal (!curr))) of {
        true -> (!curr) := [nodeVal (!curr), node ,rightChild (!curr) ],
        false -> (!curr) := [nodeVal (!curr), leftChild (!curr), node]
    }
    
    
;;
--val leftChild = \node.


