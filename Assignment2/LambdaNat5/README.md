# README
#### In the critical appraisal explain the results for sum x : 2 : 3 : 4 : # and sum 1 : 2 : 3 : x : #.
# sum 1 : 2 : 3 : x : #
# 	OUTPUT: 1 + (2 + (3 + (x + 0)))
# sum x : 2 : 3 : 4 : #
# 	OUTPUT: x + 9 
	Explanation:The reason for the difference in results from the two expressions is due to the definition of our sum function. We defined sum recursively, by defining that we add the current element with the sum after it. Therefore it goes to the end of the list (creating n recursive calls) then once it sees the Nil character, it begins adding and popping off the stack. In the first example we see this, because it adds the value of the last element, ‘x’ with 0 (the base case for #). Then it keeps adding the previous elements to this sum. In the second example, all the tail elements are successfully added together until we reach x + 9. It doesn’t evaluate x+9 because x is not an integer and the way we defined our interpreter with evalCBN, it will return the same whole expression x + 9.


#### In the critical appraisal explain what happens if one replaces the 2 in plus_two by a free variable y.
	OUTPUT:  (1 + y) : (2 + y) : (3 + y) : #

	Explanation: Now instead of distributing the addition of 2, we are distributing the addition of y. So just as before, plus_two goes through each element in the list provided and adds that value to y. In this case, we also get to see how the addition is broken up since instead of a discrete value we are yielded expressions.

#### #:# does not parse, but (#):# does. Why? Does that mean that it would make sense to change the grammar?
No, we should not change the grammar.

	Explanation:This occurs because # alone is treated as the end of a list, no elements should come after it. This is due to the way we defined our grammar ```Exp15 ::= “#” ;```. There are no patterns that should come after “#”. Also, when the parser gets to the terminal “:”, it needs an expression with level 16 on the left hand side. Since “#” is Exp15, this does not work and so the parse fails. Thus, when we parse #:#, nothing is supposed to come after the initial # so no parse is done. However, when parsing (#) instead of treating it as an end of operation character, and only a precedence level of Exp15, it is now recognized as a much higher precedence level: Exp17 (because of coercions). Now the parser will look to pattern match Exp17 followed by a terminal symbol “:”. There are no patterns for Exp17 so it drops the precedence level to Exp16, thus pattern matching the ECons rule: ```Exp16 ::= Exp16 “:” Exp15 ```. Therefore, the operation is parsed. We don’t think it makes sense to change the grammar because in our heads it makes the most sense to keep a value to determine the end of a process. Without this value, all of our functions would need to be rewritten as well as our initial definitions. Using () to change the precedence level of a value is easier to implement and forces the individual to recognize what exactly they are doing when inserting such a value. 

#### Reflect on the differences between LambdaNat5 and the Calculator. In LambdaNat5, why can't we implement arithmetic using the simple
One main difference between them is the type signature  of the eval function. In Calculator we have ```eval :: Exp -> Integer```. So it evaluates our expressions into the built in Haskell Integer type. In LambdaNat5 we have ```evalCBN :: Exp -> Exp```. So evalCBN just reduces one expression into another expression. Therefore, we do cannot use ```evalCBN (EPlus e1 e2) = (evalCBN e1) + (evalCBN e2)``` because that will evaluate the expression to an Integer. Also this will not be call by name because we are evaluating the innermost expressions first before doing the actual “plus”. If both expressions are not just simple integers, then evalCBN returns ```EPlus e1’ e2’```. This shows the call by name method. This can be seen from the first question above regarding the different outputs of the sum function. When we add ```x + 9```. x is an expression that cannot be currently evaluated, so we end up just returning the one expression.


#### Did you notice that the specification “the output-list must be sorted in case that the input-list is sorted” states an invariant? Can you use it to prove the correctness of sort (that is, that sort actually does sort)? 
This statement and specification makes sense because as we saw when we tried to sort a list with a variable like x, the insertion sort essentially removes all the values from the list leaving us with an empty list. This is technically sorted and now our process begins to insert values, 1 by 1, into the sorted list. This causes our input to always be a “sorted” list as it is a single value and our output list will be sorted as the value is inserted properly. Basically, once we have all the values removed we are simply plugging in the values where they are >= the value we are checking. Thus, making our list sorted. 

#### Reflect on the differences between LambdaNat5 and Haskell. In your experience from this assignment, how does writing code in LambdaNat5 and Haskell compare? How far did we come in implementing a functional programming language? What is missing? What can you say about how one should go about extending LambdaNat5 to a more powerful functional language (such as Haskell)?
I think the idea and philosophy of LambdaNat5 and Haskell is very similar. The syntax is obviously a little different when creating functions and recursive functions in LambdaNat5. It took some time to get familiar with, but once we did, it was easy to draw connections between the two languages and be able to translate functions back-and-forth relatively easily. I think we made good progress in implementing a functional language. We implemented the fundamental building blocks that can be combined / abstracted together to create complex expressions and functions. There is still much more to be done such as defining different types, and defining global functions. One can extend LambdaNat5 to a more powerful functional language by further developing the easier syntax and more options. For example, we translated lambda expressions to more easy, syntactic sugar: ```let A = B in C```. Also we defined how to write recursive functions with “let rec …”. Building upon LambdaNat5, we need to make sure we follow the properties of functional programming languages. The result of a function call is unique to the values of the arguments. There should be no assignments, so no side-effects, therefore no matter when or how we call the function, the result will always be equal with given arguments.
